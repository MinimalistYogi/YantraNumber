<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Repr√©sentation G√©om√©trique des Nombres (0-9999) - Style Yantra</title>
    <style>
        :root {
            --background-color: #F8F1E9;
            --canvas-background-color: #333cff; /* Fond bleu indigo pour le canevas */
            --primary-color: #4A6FA5;
            --units-color: #fcff33; /* Jaune pour les unit√©s */
            --secondary-color: #DAA520; /* Couleur Or/Dor√© */
            --tens-color: #FF1493; /* Rose fonc√© pour les dizaines */
            --tens-stroke: #C71585;
            --hundreds-color: #FF69B4; /* Rose moyen pour les centaines */
            --hundreds-stroke: #FF1493;
            --thousands-color: #FFB6C1; /* Rose p√¢le pour les milliers */
            --thousands-stroke: #FF69B4;
            --text-color: #333;
            --border-color: #ddd;
            --shadow: 0 4px 8px rgba(0,0,0,0.1);
            --transition: all 0.3s ease;
        }

        body {
            font-family: 'Poppins', 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--background-color);
            padding: 20px;
            line-height: 1.6;
            color: var(--text-color);
            transition: var(--transition);
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
        }

        .controls-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 650px;
        }

        .input-container {
            display: flex;
            align-items: center;
            flex: 1;
            min-width: 200px;
        }

        .theme-toggle {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            box-shadow: var(--shadow);
        }

        .theme-toggle:hover {
            transform: scale(1.05);
        }

        .slider-container {
            width: 100%;
            max-width: 650px;
            margin-bottom: 20px;
        }

        input[type="range"] {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background-color: #ddd;
            outline: none;
            transition: var(--transition);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }

        input[type="number"] {
            padding: 12px;
            font-size: 16px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            width: 120px;
            margin-right: 10px;
            transition: var(--transition);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        input[type="number"]:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 111, 165, 0.2);
            outline: none;
        }

        button {
            padding: 12px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: var(--transition);
            box-shadow: var(--shadow);
        }

        button:hover {
            background-color: #3a5a84;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .buttons-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap; /* Ajout pour g√©rer les boutons d'exemple */
            justify-content: center; /* Centrer les boutons */
        }

        .secondary-btn {
            background-color: #f8f9fa;
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }

        .secondary-btn:hover {
            background-color: #e9ecef;
        }

        #canvas-container {
            margin-top: 20px;
            position: relative;
            transition: var(--transition);
        }

        canvas {
            border: 1px solid var(--border-color);
            background-color: var(--canvas-background-color); /* Chang√© pour utiliser la variable */
            box-shadow: var(--shadow);
            border-radius: 8px;
            transition: var(--transition);
            display: block; /* Pour √©viter les espaces √©tranges */
            margin: auto; /* Centrer si le conteneur est plus large */
        }

        .explanation {
            margin-top: 30px;
            max-width: 650px;
            text-align: left;
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .explanation h3 {
            color: var(--primary-color);
            margin-top: 0;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
        }

        .explanation ul {
            padding-left: 20px;
        }

        .explanation li {
            margin-bottom: 8px;
        }

        .error {
            color: #e74c3c;
            margin-top: 10px;
            font-weight: 500;
            transition: var(--transition);
            height: 1.2em; /* R√©server de l'espace pour √©viter les sauts */
        }

        .legend {
            display: flex;
            justify-content: center; /* Centrer la l√©gende */
            margin-top: 15px;
            flex-wrap: wrap;
            max-width: 600px; /* Limiter la largeur */
            width: 100%;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 10px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid rgba(0,0,0,0.1); /* L√©ger bordure pour la visibilit√© */
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            width: 100%;
            max-width: 650px;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            font-weight: 500;
            color: var(--text-color);
            transition: var(--transition);
            border-bottom: 3px solid transparent;
        }

        .tab.active {
            border-bottom: 3px solid var(--primary-color);
            color: var(--primary-color);
        }

        .tab-content {
            display: none;
            width: 100%;
            max-width: 650px;
        }

        .tab-content.active {
            display: block;
        }

        body.dark-mode {
            --background-color: #2c3e50;
            --text-color: #ecf0f1;
            --border-color: #4a5c6b;
            --primary-color: #3498db;
            --secondary-color: #f1c40f; /* Or/Dor√© en mode sombre */
            --tens-color: #e84393;
            --tens-stroke: #d33682;
            --hundreds-color: #fd79a8;
            --hundreds-stroke: #e84393;
            --thousands-color: #FFD700; /* Or un peu plus clair pour milliers en sombre */
            --thousands-stroke: #DAA520;
            --canvas-background-color: #1a1e2e; /* Fond sombre du canevas */
            --units-color: #fcff33; /* Couleur des unit√©s inchang√©e */
        }

        body.dark-mode .explanation {
            background-color: #34495e;
        }

        body.dark-mode canvas {
            border-color: var(--border-color);
        }

        body.dark-mode .secondary-btn {
            background-color: #34495e;
            color: #ecf0f1;
            border-color: #4a5c6b;
        }

        body.dark-mode .secondary-btn:hover {
            background-color: #2c3e50;
        }

        body.dark-mode input[type="number"] {
             background-color: #34495e;
             color: #ecf0f1;
             border-color: #4a5c6b;
        }

        body.dark-mode input[type="range"] {
            background-color: #4a5c6b;
        }
         body.dark-mode input[type="range"]::-webkit-slider-thumb {
            background: var(--primary-color);
        }


        .fade-in {
            opacity: 0;
            animation: fadeIn 0.5s forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        @media (max-width: 768px) {
            body { padding: 10px; }
            h1 { font-size: 1.5em; }
            .controls-container { flex-direction: column; }
            .input-container { width: 100%; justify-content: center;}
            input[type="number"] { width: 100px; }
            .buttons-container { justify-content: center; }
            canvas { width: 95%; height: auto; }
            .legend { justify-content: center; }
            .tabs { max-width: 100%; }
            .tab { padding: 8px 12px; font-size: 0.9em;}
            .explanation { padding: 15px; }
        }
    </style>
</head>
<body>
    <h1>Repr√©sentation G√©om√©trique des Nombres (0-9999) - Style Yantra</h1>

    <div class="tabs">
        <button class="tab active" data-tab="visualization">Visualisation</button>
        <button class="tab" data-tab="explanation">Explication</button>
        <button class="tab" data-tab="examples">Exemples</button>
    </div>

    <div id="visualization" class="tab-content active">
        <div class="controls-container">
            <div class="input-container">
                <input type="number" id="number-input" min="0" max="9999" placeholder="0-9999" value="0">
                <button id="generate-btn">G√©n√©rer</button>
            </div>
            <button class="theme-toggle" id="theme-toggle" title="Changer de th√®me">
                ‚òÄÔ∏è
            </button>
        </div>

        <div class="slider-container">
            <label for="number-slider" style="display: block; text-align: center; margin-bottom: 5px;">Valeur: <span id="slider-value">0</span></label>
            <input type="range" id="number-slider" min="0" max="9999" value="0">
        </div>

        <div class="buttons-container">
            <button id="prev-btn" class="secondary-btn">Pr√©c√©dent</button>
            <button id="next-btn" class="secondary-btn">Suivant</button>
            <button id="random-btn" class="secondary-btn">Al√©atoire</button>
            <button id="animate-btn">Animation</button>
             <!-- Les boutons d'exemple seront ajout√©s ici par JS -->
        </div>

        <div id="error-message" class="error"></div>

        <div id="canvas-container" class="fade-in">
            <canvas id="canvas" width="600" height="600"></canvas>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--secondary-color); border: none;"></div>
                <span>Cercles Guides</span>
            </div>
             <div class="legend-item">
                <div class="legend-color" style="background-color: var(--units-color);"></div>
                <span>Unit√©s</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--tens-color);"></div>
                <span>Dizaines (P√©tales)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--hundreds-color);"></div>
                <span>Centaines (P√©tales)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--thousands-color);"></div>
                <span>Milliers (P√©tales)</span>
            </div>
        </div>
    </div>

    <div id="explanation" class="tab-content">
        <div class="explanation">
             <!-- CONTENU HTML MIS √Ä JOUR -->
            <h3>R√®gles de repr√©sentation :</h3>
            <p>Une figure g√©om√©trique est g√©n√©r√©e pour chaque nombre de 0 √† 9999, bas√©e sur des cercles concentriques et des formes repr√©sentant les unit√©s, dizaines, centaines et milliers.</p>
            <p><strong>Unit√©s (√† l'int√©rieur du premier cercle dor√©) :</strong></p>
            <ul>
                <li><strong>0</strong> : Cercle dor√© vide</li>
                <li><strong>1</strong> : Un point jaune au centre</li>
                <li><strong>2</strong> : Un segment reliant deux points oppos√©s sur le cercle</li>
                <li><strong>3</strong> : Un triangle √©quilat√©ral inscrit (sommet en haut)</li>
                <li><strong>4</strong> : Un carr√© inscrit</li>
                <li><strong>5</strong> : Un carr√© + un point au centre</li>
                <li><strong>6</strong> : Deux triangles √©quilat√©raux oppos√©s (√©toile √† 6 branches)</li>
                <li><strong>7</strong> : √âtoile √† 6 branches + un point au centre</li>
                <li><strong>8</strong> : Deux carr√©s inscrits et pivot√©s</li>
                <li><strong>9</strong> : Deux carr√©s + un point au centre</li>
            </ul>
            <p><strong>Dizaines (p√©tales stylis√©s roses fonc√©s ancr√©s sur le premier cercle dor√©) :</strong></p>
            <ul>
                <li>Le nombre de p√©tales correspond au chiffre des dizaines (1 √† 9).</li>
                <li>Les p√©tales sont r√©partis uniform√©ment autour du cercle.</li>
                <li><strong>10</strong> : 1 p√©tale en haut</li>
                <li><strong>20</strong> : 2 p√©tales (haut et bas)</li>
                <li><strong>30</strong> : 3 p√©tales en triangle</li>
                <li><strong>40-90</strong> : Distribution en polygones r√©guliers (4 p√©tales en carr√©, 5 en pentagone, etc.)</li>
            </ul>
            <p><strong>Centaines (p√©tales stylis√©s roses ancr√©s sur le second cercle dor√©) :</strong></p>
            <ul>
                <li>Le nombre de p√©tales correspond au chiffre des centaines (1 √† 9).</li>
                <li>Distribution similaire aux dizaines, sur un cercle guide plus grand.</li>
            </ul>
            <p><strong>Milliers (p√©tales stylis√©s roses clairs ancr√©s sur le troisi√®me cercle dor√©) :</strong></p>
            <ul>
                 <li>Le nombre de p√©tales correspond au chiffre des milliers (1 √† 9).</li>
                 <li>Distribution similaire aux dizaines et centaines, sur le cercle guide le plus externe.</li>
            </ul>
             <p><strong>Couleurs :</strong></p>
            <ul>
                <li>Cercles guides : Dor√©</li>
                <li>Unit√©s : Jaune</li>
                <li>Dizaines : Rose Fonc√©</li>
                <li>Centaines : Rose Moyen</li>
                <li>Milliers : Rose P√¢le / Or (mode sombre)</li>
                <li>Fond du canevas : Bleu Indigo / Bleu Nuit (mode sombre)</li>
            </ul>
        </div>
    </div>

    <div id="examples" class="tab-content">
        <div class="explanation">
            <h3>Exemples et Applications :</h3>
            <p>Cette repr√©sentation transforme les nombres en motifs visuels complexes rappelant les Yantras ou Mandalas.</p>
            <ul>
                <li><strong>Visualisation esth√©tique</strong> : Chaque nombre a une signature visuelle unique.</li>
                <li><strong>Exploration des motifs</strong> : Observer comment les chiffres interagissent pour former des motifs.</li>
                <li><strong>Potentiel m√©ditatif/artistique</strong> : Les formes peuvent √™tre utilis√©es comme base pour l'art ou la contemplation.</li>
            </ul>
            <p>Exemples notables (cliquez sur les boutons d'exemple dans l'onglet Visualisation) :</p>
            <ul>
                <li><strong>42</strong> : Carr√© jaune (2) √† l'int√©rieur, 4 p√©tales roses fonc√©s (40) sur le premier cercle.</li>
                <li><strong>100</strong> : Cercle dor√© vide (0), pas de p√©tales de dizaines, 1 p√©tale rose (100) sur le deuxi√®me cercle.</li>
                <li><strong>1423</strong> : Triangle jaune (3), 2 p√©tales roses fonc√©s (20), 4 p√©tales roses (400), 1 p√©tale rose clair/or (1000).</li>
                <li><strong>7777</strong> : √âtoile 6 branches + point central (7), 7 p√©tales roses fonc√©s (70), 7 p√©tales roses (700), 7 p√©tales roses clairs/or (7000).</li>
            </ul>
            <p>Utilisez les contr√¥les (slider, boutons) pour explorer la beaut√© math√©matique des nombres !</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const numberInput = document.getElementById('number-input');
            const numberSlider = document.getElementById('number-slider');
            const sliderValueSpan = document.getElementById('slider-value');
            const generateBtn = document.getElementById('generate-btn');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const randomBtn = document.getElementById('random-btn');
            const animateBtn = document.getElementById('animate-btn');
            const themeToggle = document.getElementById('theme-toggle');
            const errorMessage = document.getElementById('error-message');
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            const canvasContainer = document.getElementById('canvas-container');

            let isAnimating = false;
            let animationSpeed = 200; // Acc√©l√©r√© pour voir plus de formes
            let animationInterval;
            let currentNumber = 0;
            let isDarkMode = false;

            // Met √† jour la valeur affich√©e du slider
            function updateSliderValue(value) {
                 sliderValueSpan.textContent = value;
            }

            numberInput.addEventListener('input', function() {
                let value = parseInt(this.value);
                if (isNaN(value)) value = 0; // G√®re l'entr√©e vide
                value = Math.max(0, Math.min(9999, value)); // Clamp value
                this.value = value; // Met √† jour l'input si clamp√©
                numberSlider.value = value;
                currentNumber = value;
                updateSliderValue(value);
                 // Dessine imm√©diatement pendant la saisie
                // drawNumber(currentNumber); // Optionnel: dessiner en temps r√©el
            });

            // Gestionnaire pour vider l'input si n√©cessaire
            numberInput.addEventListener('blur', function() {
                if (this.value === '') {
                    this.value = '0';
                    numberSlider.value = 0;
                    currentNumber = 0;
                    updateSliderValue(0);
                    drawNumber(0);
                }
            });


            numberSlider.addEventListener('input', function() {
                const value = parseInt(this.value);
                numberInput.value = value;
                currentNumber = value;
                updateSliderValue(value);
                drawNumber(value); // Mise √† jour en temps r√©el avec le slider
            });

            generateBtn.addEventListener('click', function() {
                const number = parseInt(numberInput.value);
                if (isNaN(number) || number < 0 || number > 9999) {
                    errorMessage.textContent = "Nombre invalide (0-9999).";
                    // Optionnellement, remettre √† 0 ou laisser
                    numberInput.value = currentNumber; // R√©tablit la derni√®re valeur valide
                    return;
                }
                errorMessage.textContent = "";
                currentNumber = number;
                updateSliderValue(number);
                drawNumberWithAnimation(number);
            });

            prevBtn.addEventListener('click', function() {
                if (currentNumber > 0) {
                    currentNumber--;
                    updateInputs();
                    drawNumberWithAnimation(currentNumber);
                }
            });

            nextBtn.addEventListener('click', function() {
                if (currentNumber < 9999) {
                    currentNumber++;
                    updateInputs();
                    drawNumberWithAnimation(currentNumber);
                }
            });

            randomBtn.addEventListener('click', function() {
                const randomNum = Math.floor(Math.random() * 10000);
                currentNumber = randomNum;
                updateInputs();
                drawNumberWithAnimation(randomNum);
            });

            animateBtn.addEventListener('click', function() {
                if (isAnimating) {
                    stopAnimation();
                } else {
                    startAnimation();
                }
            });

            themeToggle.addEventListener('click', function() {
                toggleTheme();
            });

            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));
                    this.classList.add('active');
                    document.getElementById(tabId).classList.add('active');
                });
            });

            function updateInputs() {
                numberInput.value = currentNumber;
                numberSlider.value = currentNumber;
                updateSliderValue(currentNumber);
            }

            function startAnimation() {
                if (isAnimating) return;
                isAnimating = true;
                animateBtn.textContent = "Arr√™ter";
                animateBtn.style.backgroundColor = '#e74c3c'; // Indicateur visuel
                animationInterval = setInterval(function() {
                    if (currentNumber < 9999) {
                        currentNumber++;
                    } else {
                        currentNumber = 0; // Boucle
                    }
                    updateInputs();
                    drawNumber(currentNumber); // Dessin direct sans fade pour la fluidit√©
                }, animationSpeed);
            }

            function stopAnimation() {
                if (!isAnimating) return;
                isAnimating = false;
                animateBtn.textContent = "Animation";
                 animateBtn.style.backgroundColor = ''; // R√©tablir couleur par d√©faut
                clearInterval(animationInterval);
            }

            function toggleTheme() {
                isDarkMode = !isDarkMode;
                document.body.classList.toggle('dark-mode', isDarkMode);
                themeToggle.textContent = isDarkMode ? 'üåô' : '‚òÄÔ∏è';
                // Redessiner avec les nouvelles couleurs du th√®me
                drawNumber(currentNumber);
            }

            function drawNumberWithAnimation(number) {
                canvasContainer.classList.remove('fade-in');
                // Force reflow/repaint pour que l'animation red√©marre
                void canvasContainer.offsetWidth;
                canvasContainer.classList.add('fade-in');
                drawNumber(number);
            }

            function getColors() {
                const styles = getComputedStyle(document.documentElement);
                return {
                    BACKGROUND_COLOR: styles.getPropertyValue('--background-color').trim(),
                    CANVAS_BACKGROUND_COLOR: styles.getPropertyValue('--canvas-background-color').trim(),
                    GOLD_COLOR: styles.getPropertyValue('--secondary-color').trim(),
                    UNITS_COLOR: styles.getPropertyValue('--units-color').trim(),
                    TENS_COLOR: styles.getPropertyValue('--tens-color').trim(),
                    TENS_STROKE: styles.getPropertyValue('--tens-stroke').trim(),
                    HUNDREDS_COLOR: styles.getPropertyValue('--hundreds-color').trim(),
                    HUNDREDS_STROKE: styles.getPropertyValue('--hundreds-stroke').trim(),
                    THOUSANDS_COLOR: styles.getPropertyValue('--thousands-color').trim(),
                    THOUSANDS_STROKE: styles.getPropertyValue('--thousands-stroke').trim(),
                    TEXT_COLOR: styles.getPropertyValue('--text-color').trim() // Couleur du texte du num√©ro
                };
            }

            function drawNumber(number) {
                const colors = getColors();
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                const centerX = canvasWidth / 2;
                const centerY = canvasHeight / 2;

                // Base radius and petal sizes
                const R = Math.min(canvasWidth, canvasHeight) / 8; // Ajust√© pour laisser plus de place aux p√©tales
                const pointRadius = R * 0.08; // Radius des points unit√©s relatif √† R

                // Tailles des p√©tales (ajustables)
                const petalSizeBase = R * 0.45;
                const petalSizeTens = petalSizeBase * 1.0;
                const petalSizeHundreds = petalSizeBase * 1.5;
                const petalSizeThousands = petalSizeBase * 2.2;

                // Rayons des cercles guides (ajust√©s pour l'espacement des p√©tales)
                // Le rayon R est pour les unit√©s ET la base des p√©tales de dizaines
                const hundredsCircleRadius = R + petalSizeTens * 0.6; // Espace apr√®s les p√©tales dizaines
                const thousandsCircleRadius = hundredsCircleRadius + petalSizeHundreds * 0.7; // Espace apr√®s les p√©tales centaines

                // Fond du canevas
                ctx.fillStyle = colors.CANVAS_BACKGROUND_COLOR;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                const thousands = Math.floor(number / 1000);
                const hundreds = Math.floor((number % 1000) / 100);
                const tens = Math.floor((number % 100) / 10);
                const units = number % 10;

                // Affichage du nombre et d√©composition (optionnel, mais utile)
                ctx.fillStyle = colors.TEXT_COLOR; // Utiliser la couleur du th√®me pour le texte
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                //ctx.fillText(`Nombre: ${number}`, centerX, 30); // On peut commenter si trop charg√©
                ctx.font = '14px Arial';
                //ctx.fillText(`M:${thousands} C:${hundreds} D:${tens} U:${units}`, centerX, 50); // Version courte

                // Dessiner les cercles guides et les anneaux de p√©tales
                 // Cercle guide externe (Milliers)
                if (thousands > 0) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, thousandsCircleRadius, 0, 2 * Math.PI);
                    ctx.strokeStyle = colors.GOLD_COLOR;
                    ctx.lineWidth = 2; // Plus fin pour les guides
                    ctx.stroke();
                    drawPetalRing(thousands, colors.THOUSANDS_COLOR, colors.THOUSANDS_STROKE, centerX, centerY, thousandsCircleRadius, petalSizeThousands);
                }

                // Cercle guide interm√©diaire (Centaines)
                 if (hundreds > 0) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, hundredsCircleRadius, 0, 2 * Math.PI);
                    ctx.strokeStyle = colors.GOLD_COLOR;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    drawPetalRing(hundreds, colors.HUNDREDS_COLOR, colors.HUNDREDS_STROKE, centerX, centerY, hundredsCircleRadius, petalSizeHundreds);
                }

                 // Cercle guide interne (Dizaines / Unit√©s)
                ctx.beginPath();
                ctx.arc(centerX, centerY, R, 0, 2 * Math.PI);
                ctx.strokeStyle = colors.GOLD_COLOR;
                ctx.lineWidth = 2;
                ctx.stroke();

                 // Dessiner les p√©tales pour les dizaines sur le cercle interne R
                if (tens > 0) {
                    drawPetalRing(tens, colors.TENS_COLOR, colors.TENS_STROKE, centerX, centerY, R, petalSizeTens);
                }

                // Dessiner les unit√©s √† l'int√©rieur du cercle R
                drawUnits(units, colors, centerX, centerY, R * 0.9, pointRadius); // L√©g√®rement r√©duit pour ne pas toucher le cercle
            }

            // Fonction qui dessine un anneau de p√©tales
            function drawPetalRing(count, fillColor, strokeColor, centerX, centerY, radius, petalSize) {
                if (count === 0) return; // Ne rien dessiner si count est 0
                for (let i = 0; i < count; i++) {
                    // Angle: -PI/2 pour commencer en haut, distribue uniform√©ment
                    let angle = -Math.PI / 2 + (i * 2 * Math.PI / count);

                    // Position de la base du p√©tale sur le cercle guide
                    const petalBaseX = centerX + radius * Math.cos(angle);
                    const petalBaseY = centerY + radius * Math.sin(angle);

                    // Dessine le p√©tale individuel
                    drawPetal(petalBaseX, petalBaseY, angle, petalSize, fillColor, strokeColor);
                }
            }

            // NOUVELLE FONCTION drawPetal pour un style Yantra/Lotus
            function drawPetal(x, y, angle, petalSize, fillColor, strokeColor) {
                // x, y: point de base du p√©tale sur le cercle guide
                // angle: direction radiale vers l'ext√©rieur (o√π pointe le p√©tale)
                // petalSize: facteur de taille pour le p√©tale
                // fillColor, strokeColor: couleurs

                // Dimensions du p√©tale (ajustables pour l'esth√©tique)
                const petalLength = petalSize * 2.8; // Longueur du p√©tale
                const petalWidth = petalSize * 1.6;  // Largeur maximale du p√©tale

                ctx.save(); // Sauvegarde l'√©tat actuel (transformations, styles)
                ctx.translate(x, y); // Place l'origine au point de base du p√©tale
                ctx.rotate(angle + Math.PI / 2); // Oriente le canvas pour que le p√©tale pointe vers le "haut" (axe Y n√©gatif local)

                // Coordonn√©es relatives (base √† 0,0, pointe vers le haut sur l'axe Y)
                const baseX = 0;
                const baseY = 0;
                const tipX = 0;
                const tipY = -petalLength; // Pointe vers le Y n√©gatif apr√®s rotation

                // Points de contr√¥le pour les courbes de B√©zier cubiques
                // Ajustez ces valeurs pour diff√©rentes formes de p√©tales
                // Courbe 1 (c√¥t√© droit, de la base √† la pointe)
                const cp1X = petalWidth * 0.5;  // Contr√¥le la largeur √† la base
                const cp1Y = -petalLength * 0.3;
                const cp2X = petalWidth * 0.1;  // Contr√¥le la largeur pr√®s de la pointe
                const cp2Y = -petalLength * 0.8;

                // Courbe 2 (c√¥t√© gauche, de la pointe √† la base) - sym√©trique
                const cp3X = -petalWidth * 0.1; // Sym√©trique de cp2X
                const cp3Y = -petalLength * 0.8; // Sym√©trique de cp2Y
                const cp4X = -petalWidth * 0.5;  // Sym√©trique de cp1X
                const cp4Y = -petalLength * 0.3; // Sym√©trique de cp1Y

                ctx.beginPath();
                ctx.moveTo(baseX, baseY);
                // Dessine le c√¥t√© droit du p√©tale
                ctx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, tipX, tipY);
                // Dessine le c√¥t√© gauche du p√©tale
                ctx.bezierCurveTo(cp3X, cp3Y, cp4X, cp4Y, baseX, baseY);
                ctx.closePath();

                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 1.2; // Contour fin
                ctx.stroke();

                ctx.restore(); // Restaure l'√©tat pr√©c√©dent du contexte (translation/rotation)
            }


            // Fonction pour dessiner les unit√©s (inchang√©e, sauf les couleurs)
             function drawUnits(units, colors, centerX, centerY, innerRadius, pointRadius) {
                ctx.fillStyle = colors.UNITS_COLOR; // Couleur pour le remplissage
                ctx.strokeStyle = colors.UNITS_COLOR; // Couleur pour les lignes
                ctx.lineWidth = 2;

                switch(units) {
                    case 0: break; // Rien √† dessiner
                    case 1: // Point central
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, pointRadius * 1.5, 0, 2 * Math.PI); // Un peu plus gros
                        ctx.fill();
                        break;
                    case 2: // Segment vertical
                        drawPolygon(2, -Math.PI/2, colors, centerX, centerY, innerRadius, pointRadius);
                        break;
                    case 3: // Triangle (pointe en haut)
                        drawPolygon(3, -Math.PI / 2, colors, centerX, centerY, innerRadius, pointRadius);
                        break;
                    case 4: // Carr√©
                         drawPolygon(4, Math.PI / 4, colors, centerX, centerY, innerRadius, pointRadius); // Tourn√© pour √™tre droit
                        break;
                    case 5: // Carr√© + point central
                        drawPolygon(4, Math.PI / 4, colors, centerX, centerY, innerRadius, pointRadius);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, pointRadius, 0, 2 * Math.PI);
                        ctx.fill();
                        break;
                    case 6: // Deux triangles (√©toile 6 branches)
                        drawPolygon(3, -Math.PI / 2, colors, centerX, centerY, innerRadius, pointRadius);
                        drawPolygon(3, Math.PI / 2, colors, centerX, centerY, innerRadius, pointRadius);
                        break;
                    case 7: // √âtoile 6 branches + point central
                         drawPolygon(3, -Math.PI / 2, colors, centerX, centerY, innerRadius, pointRadius);
                         drawPolygon(3, Math.PI / 2, colors, centerX, centerY, innerRadius, pointRadius);
                         ctx.beginPath();
                         ctx.arc(centerX, centerY, pointRadius, 0, 2 * Math.PI);
                         ctx.fill();
                        break;
                    case 8: // Deux carr√©s tourn√©s
                        drawPolygon(4, Math.PI / 4, colors, centerX, centerY, innerRadius, pointRadius);
                        drawPolygon(4, 0, colors, centerX, centerY, innerRadius, pointRadius); // Deuxi√®me carr√© non tourn√©
                        break;
                    case 9: // Deux carr√©s + point central
                        drawPolygon(4, Math.PI / 4, colors, centerX, centerY, innerRadius, pointRadius);
                        drawPolygon(4, 0, colors, centerX, centerY, innerRadius, pointRadius);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, pointRadius, 0, 2 * Math.PI);
                        ctx.fill();
                        break;
                }
            }

             // Fonction helper pour dessiner polygones/segments inscrits (utilis√©e par drawUnits)
            function drawPolygon(sides, rotationOffset, colors, centerX, centerY, radius, pointRadius) {
                if (sides < 2) return; // Un polygone a au moins 2 c√¥t√©s (segment)

                const points = [];
                // Calcule les sommets du polygone
                for (let i = 0; i < sides; i++) {
                    // Angle pour chaque sommet
                    const angle = rotationOffset + (i * 2 * Math.PI / sides);
                    // Coordonn√©es du sommet sur le cercle
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    points.push({ x, y });

                     // Dessine un petit cercle √† chaque sommet (optionnel mais visuel)
                    ctx.beginPath();
                    ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = colors.UNITS_COLOR; // Utilise d√©j√† la bonne couleur
                    ctx.fill();
                }

                // Dessine les lignes reliant les sommets
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < sides; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                 // Ferme le polygone (ou termine le segment si sides=2)
                if (sides > 2) {
                    ctx.closePath();
                }
                ctx.strokeStyle = colors.UNITS_COLOR; // Utilise d√©j√† la bonne couleur
                ctx.lineWidth = 2;
                ctx.stroke();
            }


            // Initialisation
            updateSliderValue(0); // Afficher 0 au d√©but
            drawNumber(0); // Dessiner l'√©tat initial (0)

            // Ajout des boutons d'exemple dynamiquement
            const exampleNumbers = [42, 100, 1423, 7777, 8008, 9999, 3141, 2718];
            const buttonsContainer = document.querySelector('.buttons-container');
            exampleNumbers.forEach(num => {
                const btn = document.createElement('button');
                btn.classList.add('secondary-btn');
                btn.textContent = `Ex: ${num}`;
                btn.addEventListener('click', function() {
                    currentNumber = num;
                    updateInputs();
                    drawNumberWithAnimation(num);
                     // Optionnel: passer √† l'onglet visualisation si on est ailleurs
                    if (!document.getElementById('visualization').classList.contains('active')) {
                         tabs.forEach(t => t.classList.remove('active'));
                         tabContents.forEach(tc => tc.classList.remove('active'));
                         document.querySelector('.tab[data-tab="visualization"]').classList.add('active');
                         document.getElementById('visualization').classList.add('active');
                    }
                });
                buttonsContainer.appendChild(btn);
            });

             // Gestion des fl√®ches clavier pour Pr√©c√©dent/Suivant
            document.addEventListener('keydown', function(e) {
                // Ne pas interf√©rer si l'utilisateur tape dans l'input
                if (document.activeElement === numberInput) return;

                if (e.key === 'ArrowLeft') {
                    e.preventDefault(); // Emp√™che le scroll horizontal
                    prevBtn.click(); // Simule un clic sur le bouton Pr√©c√©dent
                } else if (e.key === 'ArrowRight') {
                     e.preventDefault(); // Emp√™che le scroll horizontal
                     nextBtn.click(); // Simule un clic sur le bouton Suivant
                }
            });

        });
    </script>
</body>
</html>
