<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Représentation Géométrique des Nombres (0-9999) - Style Yantra</title>
    <style>
        :root {
            --background-color: #F8F1E9;
            --canvas-background-color: #333cff; /* Fond bleu indigo pour le canevas */
            --primary-color: #4A6FA5;
            --units-color: #fcff33; /* Jaune pour les unités */
            --secondary-color: #DAA520; /* Couleur Or/Doré */
            --tens-color: #FF1493; /* Rose foncé pour les dizaines */
            --tens-stroke: #C71585;
            --hundreds-color: #FF69B4; /* Rose moyen pour les centaines */
            --hundreds-stroke: #FF1493;
            --thousands-color: #FFB6C1; /* Rose pâle pour les milliers */
            --thousands-stroke: #FF69B4;
            --text-color: #333;
            --border-color: #ddd;
            --shadow: 0 4px 8px rgba(0,0,0,0.1);
            --transition: all 0.3s ease;
        }

        body {
            font-family: 'Poppins', 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--background-color);
            padding: 20px;
            line-height: 1.6;
            color: var(--text-color);
            transition: var(--transition);
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
        }

        .controls-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 650px;
        }

        .input-container {
            display: flex;
            align-items: center;
            flex: 1;
            min-width: 200px;
        }

        .theme-toggle {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            box-shadow: var(--shadow);
        }

        .theme-toggle:hover {
            transform: scale(1.05);
        }

        .slider-container {
            width: 100%;
            max-width: 650px;
            margin-bottom: 20px;
        }

        input[type="range"] {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background-color: #ddd;
            outline: none;
            transition: var(--transition);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }

        input[type="number"] {
            padding: 12px;
            font-size: 16px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            width: 120px;
            margin-right: 10px;
            transition: var(--transition);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        input[type="number"]:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 111, 165, 0.2);
            outline: none;
        }

        button {
            padding: 12px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: var(--transition);
            box-shadow: var(--shadow);
        }

        button:hover {
            background-color: #3a5a84;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .buttons-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap; /* Ajout pour gérer les boutons d'exemple */
            justify-content: center; /* Centrer les boutons */
        }

        .secondary-btn {
            background-color: #f8f9fa;
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }

        .secondary-btn:hover {
            background-color: #e9ecef;
        }

        #canvas-container {
            margin-top: 20px;
            position: relative;
            transition: var(--transition);
        }

        canvas {
            border: 1px solid var(--border-color);
            background-color: var(--canvas-background-color); /* Changé pour utiliser la variable */
            box-shadow: var(--shadow);
            border-radius: 8px;
            transition: var(--transition);
            display: block; /* Pour éviter les espaces étranges */
            margin: auto; /* Centrer si le conteneur est plus large */
        }

        .explanation {
            margin-top: 30px;
            max-width: 650px;
            text-align: left;
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .explanation h3 {
            color: var(--primary-color);
            margin-top: 0;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
        }

        .explanation ul {
            padding-left: 20px;
        }

        .explanation li {
            margin-bottom: 8px;
        }

        .error {
            color: #e74c3c;
            margin-top: 10px;
            font-weight: 500;
            transition: var(--transition);
            height: 1.2em; /* Réserver de l'espace pour éviter les sauts */
        }

        .legend {
            display: flex;
            justify-content: center; /* Centrer la légende */
            margin-top: 15px;
            flex-wrap: wrap;
            max-width: 600px; /* Limiter la largeur */
            width: 100%;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 10px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid rgba(0,0,0,0.1); /* Léger bordure pour la visibilité */
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            width: 100%;
            max-width: 650px;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            font-weight: 500;
            color: var(--text-color);
            transition: var(--transition);
            border-bottom: 3px solid transparent;
        }

        .tab.active {
            border-bottom: 3px solid var(--primary-color);
            color: var(--primary-color);
        }

        .tab-content {
            display: none;
            width: 100%;
            max-width: 650px;
        }

        .tab-content.active {
            display: block;
        }

        body.dark-mode {
            --background-color: #2c3e50;
            --text-color: #ecf0f1;
            --border-color: #4a5c6b;
            --primary-color: #3498db;
            --secondary-color: #f1c40f; /* Or/Doré en mode sombre */
            --tens-color: #e84393;
            --tens-stroke: #d33682;
            --hundreds-color: #fd79a8;
            --hundreds-stroke: #e84393;
            --thousands-color: #FFD700; /* Or un peu plus clair pour milliers en sombre */
            --thousands-stroke: #DAA520;
            --canvas-background-color: #1a1e2e; /* Fond sombre du canevas */
            --units-color: #fcff33; /* Couleur des unités inchangée */
        }

        body.dark-mode .explanation {
            background-color: #34495e;
        }

        body.dark-mode canvas {
            border-color: var(--border-color);
        }

        body.dark-mode .secondary-btn {
            background-color: #34495e;
            color: #ecf0f1;
            border-color: #4a5c6b;
        }

        body.dark-mode .secondary-btn:hover {
            background-color: #2c3e50;
        }

        body.dark-mode input[type="number"] {
             background-color: #34495e;
             color: #ecf0f1;
             border-color: #4a5c6b;
        }

        body.dark-mode input[type="range"] {
            background-color: #4a5c6b;
        }
         body.dark-mode input[type="range"]::-webkit-slider-thumb {
            background: var(--primary-color);
        }


        .fade-in {
            opacity: 0;
            animation: fadeIn 0.5s forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        @media (max-width: 768px) {
            body { padding: 10px; }
            h1 { font-size: 1.5em; }
            .controls-container { flex-direction: column; }
            .input-container { width: 100%; justify-content: center;}
            input[type="number"] { width: 100px; }
            .buttons-container { justify-content: center; }
            canvas { width: 95%; height: auto; }
            .legend { justify-content: center; }
            .tabs { max-width: 100%; }
            .tab { padding: 8px 12px; font-size: 0.9em;}
            .explanation { padding: 15px; }
        }
    </style>
</head>
<body>
    <h1>Représentation Géométrique des Nombres (0-9999) - Style Yantra</h1>

    <div class="tabs">
        <button class="tab active" data-tab="visualization">Visualisation</button>
        <button class="tab" data-tab="explanation">Explication</button>
        <button class="tab" data-tab="examples">Exemples</button>
    </div>

    <div id="visualization" class="tab-content active">
        <div class="controls-container">
            <div class="input-container">
                <input type="number" id="number-input" min="0" max="9999" placeholder="0-9999" value="0">
                <button id="generate-btn">Générer</button>
            </div>
            <button class="theme-toggle" id="theme-toggle" title="Changer de thème">
                ☀️
            </button>
        </div>

        <div class="slider-container">
            <label for="number-slider" style="display: block; text-align: center; margin-bottom: 5px;">Valeur: <span id="slider-value">0</span></label>
            <input type="range" id="number-slider" min="0" max="9999" value="0">
        </div>

        <div class="buttons-container">
            <button id="prev-btn" class="secondary-btn">Précédent</button>
            <button id="next-btn" class="secondary-btn">Suivant</button>
            <button id="random-btn" class="secondary-btn">Aléatoire</button>
            <button id="animate-btn">Animation</button>
             <!-- Les boutons d'exemple seront ajoutés ici par JS -->
        </div>

        <div id="error-message" class="error"></div>

        <div id="canvas-container" class="fade-in">
            <canvas id="canvas" width="600" height="600"></canvas>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--secondary-color); border: none;"></div>
                <span>Cercles Guides</span>
            </div>
             <div class="legend-item">
                <div class="legend-color" style="background-color: var(--units-color);"></div>
                <span>Unités</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--tens-color);"></div>
                <span>Dizaines (Pétales)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--hundreds-color);"></div>
                <span>Centaines (Pétales)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: var(--thousands-color);"></div>
                <span>Milliers (Pétales)</span>
            </div>
        </div>
    </div>

    <div id="explanation" class="tab-content">
        <div class="explanation">
             <!-- CONTENU HTML MIS À JOUR -->
            <h3>Règles de représentation :</h3>
            <p>Une figure géométrique est générée pour chaque nombre de 0 à 9999, basée sur des cercles concentriques et des formes représentant les unités, dizaines, centaines et milliers.</p>
            <p><strong>Unités (à l'intérieur du premier cercle doré) :</strong></p>
            <ul>
                <li><strong>0</strong> : Cercle doré vide</li>
                <li><strong>1</strong> : Un point jaune au centre</li>
                <li><strong>2</strong> : Un segment reliant deux points opposés sur le cercle</li>
                <li><strong>3</strong> : Un triangle équilatéral inscrit (sommet en haut)</li>
                <li><strong>4</strong> : Un carré inscrit</li>
                <li><strong>5</strong> : Un carré + un point au centre</li>
                <li><strong>6</strong> : Deux triangles équilatéraux opposés (étoile à 6 branches)</li>
                <li><strong>7</strong> : Étoile à 6 branches + un point au centre</li>
                <li><strong>8</strong> : Deux carrés inscrits et pivotés</li>
                <li><strong>9</strong> : Deux carrés + un point au centre</li>
            </ul>
            <p><strong>Dizaines (pétales stylisés roses foncés ancrés sur le premier cercle doré) :</strong></p>
            <ul>
                <li>Le nombre de pétales correspond au chiffre des dizaines (1 à 9).</li>
                <li>Les pétales sont répartis uniformément autour du cercle.</li>
                <li><strong>10</strong> : 1 pétale en haut</li>
                <li><strong>20</strong> : 2 pétales (haut et bas)</li>
                <li><strong>30</strong> : 3 pétales en triangle</li>
                <li><strong>40-90</strong> : Distribution en polygones réguliers (4 pétales en carré, 5 en pentagone, etc.)</li>
            </ul>
            <p><strong>Centaines (pétales stylisés roses ancrés sur le second cercle doré) :</strong></p>
            <ul>
                <li>Le nombre de pétales correspond au chiffre des centaines (1 à 9).</li>
                <li>Distribution similaire aux dizaines, sur un cercle guide plus grand.</li>
            </ul>
            <p><strong>Milliers (pétales stylisés roses clairs ancrés sur le troisième cercle doré) :</strong></p>
            <ul>
                 <li>Le nombre de pétales correspond au chiffre des milliers (1 à 9).</li>
                 <li>Distribution similaire aux dizaines et centaines, sur le cercle guide le plus externe.</li>
            </ul>
             <p><strong>Couleurs :</strong></p>
            <ul>
                <li>Cercles guides : Doré</li>
                <li>Unités : Jaune</li>
                <li>Dizaines : Rose Foncé</li>
                <li>Centaines : Rose Moyen</li>
                <li>Milliers : Rose Pâle / Or (mode sombre)</li>
                <li>Fond du canevas : Bleu Indigo / Bleu Nuit (mode sombre)</li>
            </ul>
        </div>
    </div>

    <div id="examples" class="tab-content">
        <div class="explanation">
            <h3>Exemples et Applications :</h3>
            <p>Cette représentation transforme les nombres en motifs visuels complexes rappelant les Yantras ou Mandalas.</p>
            <ul>
                <li><strong>Visualisation esthétique</strong> : Chaque nombre a une signature visuelle unique.</li>
                <li><strong>Exploration des motifs</strong> : Observer comment les chiffres interagissent pour former des motifs.</li>
                <li><strong>Potentiel méditatif/artistique</strong> : Les formes peuvent être utilisées comme base pour l'art ou la contemplation.</li>
            </ul>
            <p>Exemples notables (cliquez sur les boutons d'exemple dans l'onglet Visualisation) :</p>
            <ul>
                <li><strong>42</strong> : Carré jaune (2) à l'intérieur, 4 pétales roses foncés (40) sur le premier cercle.</li>
                <li><strong>100</strong> : Cercle doré vide (0), pas de pétales de dizaines, 1 pétale rose (100) sur le deuxième cercle.</li>
                <li><strong>1423</strong> : Triangle jaune (3), 2 pétales roses foncés (20), 4 pétales roses (400), 1 pétale rose clair/or (1000).</li>
                <li><strong>7777</strong> : Étoile 6 branches + point central (7), 7 pétales roses foncés (70), 7 pétales roses (700), 7 pétales roses clairs/or (7000).</li>
            </ul>
            <p>Utilisez les contrôles (slider, boutons) pour explorer la beauté mathématique des nombres !</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const numberInput = document.getElementById('number-input');
            const numberSlider = document.getElementById('number-slider');
            const sliderValueSpan = document.getElementById('slider-value');
            const generateBtn = document.getElementById('generate-btn');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const randomBtn = document.getElementById('random-btn');
            const animateBtn = document.getElementById('animate-btn');
            const themeToggle = document.getElementById('theme-toggle');
            const errorMessage = document.getElementById('error-message');
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            const canvasContainer = document.getElementById('canvas-container');

            let isAnimating = false;
            let animationSpeed = 200; // Accéléré pour voir plus de formes
            let animationInterval;
            let currentNumber = 0;
            let isDarkMode = false;

            // Met à jour la valeur affichée du slider
            function updateSliderValue(value) {
                 sliderValueSpan.textContent = value;
            }

            numberInput.addEventListener('input', function() {
                let value = parseInt(this.value);
                if (isNaN(value)) value = 0; // Gère l'entrée vide
                value = Math.max(0, Math.min(9999, value)); // Clamp value
                this.value = value; // Met à jour l'input si clampé
                numberSlider.value = value;
                currentNumber = value;
                updateSliderValue(value);
                 // Dessine immédiatement pendant la saisie
                // drawNumber(currentNumber); // Optionnel: dessiner en temps réel
            });

            // Gestionnaire pour vider l'input si nécessaire
            numberInput.addEventListener('blur', function() {
                if (this.value === '') {
                    this.value = '0';
                    numberSlider.value = 0;
                    currentNumber = 0;
                    updateSliderValue(0);
                    drawNumber(0);
                }
            });


            numberSlider.addEventListener('input', function() {
                const value = parseInt(this.value);
                numberInput.value = value;
                currentNumber = value;
                updateSliderValue(value);
                drawNumber(value); // Mise à jour en temps réel avec le slider
            });

            generateBtn.addEventListener('click', function() {
                const number = parseInt(numberInput.value);
                if (isNaN(number) || number < 0 || number > 9999) {
                    errorMessage.textContent = "Nombre invalide (0-9999).";
                    // Optionnellement, remettre à 0 ou laisser
                    numberInput.value = currentNumber; // Rétablit la dernière valeur valide
                    return;
                }
                errorMessage.textContent = "";
                currentNumber = number;
                updateSliderValue(number);
                drawNumberWithAnimation(number);
            });

            prevBtn.addEventListener('click', function() {
                if (currentNumber > 0) {
                    currentNumber--;
                    updateInputs();
                    drawNumberWithAnimation(currentNumber);
                }
            });

            nextBtn.addEventListener('click', function() {
                if (currentNumber < 9999) {
                    currentNumber++;
                    updateInputs();
                    drawNumberWithAnimation(currentNumber);
                }
            });

            randomBtn.addEventListener('click', function() {
                const randomNum = Math.floor(Math.random() * 10000);
                currentNumber = randomNum;
                updateInputs();
                drawNumberWithAnimation(randomNum);
            });

            animateBtn.addEventListener('click', function() {
                if (isAnimating) {
                    stopAnimation();
                } else {
                    startAnimation();
                }
            });

            themeToggle.addEventListener('click', function() {
                toggleTheme();
            });

            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));
                    this.classList.add('active');
                    document.getElementById(tabId).classList.add('active');
                });
            });

            function updateInputs() {
                numberInput.value = currentNumber;
                numberSlider.value = currentNumber;
                updateSliderValue(currentNumber);
            }

            function startAnimation() {
                if (isAnimating) return;
                isAnimating = true;
                animateBtn.textContent = "Arrêter";
                animateBtn.style.backgroundColor = '#e74c3c'; // Indicateur visuel
                animationInterval = setInterval(function() {
                    if (currentNumber < 9999) {
                        currentNumber++;
                    } else {
                        currentNumber = 0; // Boucle
                    }
                    updateInputs();
                    drawNumber(currentNumber); // Dessin direct sans fade pour la fluidité
                }, animationSpeed);
            }

            function stopAnimation() {
                if (!isAnimating) return;
                isAnimating = false;
                animateBtn.textContent = "Animation";
                 animateBtn.style.backgroundColor = ''; // Rétablir couleur par défaut
                clearInterval(animationInterval);
            }

            function toggleTheme() {
                isDarkMode = !isDarkMode;
                document.body.classList.toggle('dark-mode', isDarkMode);
                themeToggle.textContent = isDarkMode ? '🌙' : '☀️';
                // Redessiner avec les nouvelles couleurs du thème
                drawNumber(currentNumber);
            }

            function drawNumberWithAnimation(number) {
                canvasContainer.classList.remove('fade-in');
                // Force reflow/repaint pour que l'animation redémarre
                void canvasContainer.offsetWidth;
                canvasContainer.classList.add('fade-in');
                drawNumber(number);
            }

            function getColors() {
                const styles = getComputedStyle(document.documentElement);
                return {
                    BACKGROUND_COLOR: styles.getPropertyValue('--background-color').trim(),
                    CANVAS_BACKGROUND_COLOR: styles.getPropertyValue('--canvas-background-color').trim(),
                    GOLD_COLOR: styles.getPropertyValue('--secondary-color').trim(),
                    UNITS_COLOR: styles.getPropertyValue('--units-color').trim(),
                    TENS_COLOR: styles.getPropertyValue('--tens-color').trim(),
                    TENS_STROKE: styles.getPropertyValue('--tens-stroke').trim(),
                    HUNDREDS_COLOR: styles.getPropertyValue('--hundreds-color').trim(),
                    HUNDREDS_STROKE: styles.getPropertyValue('--hundreds-stroke').trim(),
                    THOUSANDS_COLOR: styles.getPropertyValue('--thousands-color').trim(),
                    THOUSANDS_STROKE: styles.getPropertyValue('--thousands-stroke').trim(),
                    TEXT_COLOR: styles.getPropertyValue('--text-color').trim() // Couleur du texte du numéro
                };
            }

            function drawNumber(number) {
                const colors = getColors();
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                const centerX = canvasWidth / 2;
                const centerY = canvasHeight / 2;

                // Base radius and petal sizes
                const R = Math.min(canvasWidth, canvasHeight) / 8; // Ajusté pour laisser plus de place aux pétales
                const pointRadius = R * 0.08; // Radius des points unités relatif à R

                // Tailles des pétales (ajustables)
                const petalSizeBase = R * 0.45;
                const petalSizeTens = petalSizeBase * 1.0;
                const petalSizeHundreds = petalSizeBase * 1.5;
                const petalSizeThousands = petalSizeBase * 2.2;

                // Rayons des cercles guides (ajustés pour l'espacement des pétales)
                // Le rayon R est pour les unités ET la base des pétales de dizaines
                const hundredsCircleRadius = R + petalSizeTens * 0.6; // Espace après les pétales dizaines
                const thousandsCircleRadius = hundredsCircleRadius + petalSizeHundreds * 0.7; // Espace après les pétales centaines

                // Fond du canevas
                ctx.fillStyle = colors.CANVAS_BACKGROUND_COLOR;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                const thousands = Math.floor(number / 1000);
                const hundreds = Math.floor((number % 1000) / 100);
                const tens = Math.floor((number % 100) / 10);
                const units = number % 10;

                // Affichage du nombre et décomposition (optionnel, mais utile)
                ctx.fillStyle = colors.TEXT_COLOR; // Utiliser la couleur du thème pour le texte
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                //ctx.fillText(`Nombre: ${number}`, centerX, 30); // On peut commenter si trop chargé
                ctx.font = '14px Arial';
                //ctx.fillText(`M:${thousands} C:${hundreds} D:${tens} U:${units}`, centerX, 50); // Version courte

                // Dessiner les cercles guides et les anneaux de pétales
                 // Cercle guide externe (Milliers)
                if (thousands > 0) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, thousandsCircleRadius, 0, 2 * Math.PI);
                    ctx.strokeStyle = colors.GOLD_COLOR;
                    ctx.lineWidth = 2; // Plus fin pour les guides
                    ctx.stroke();
                    drawPetalRing(thousands, colors.THOUSANDS_COLOR, colors.THOUSANDS_STROKE, centerX, centerY, thousandsCircleRadius, petalSizeThousands);
                }

                // Cercle guide intermédiaire (Centaines)
                 if (hundreds > 0) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, hundredsCircleRadius, 0, 2 * Math.PI);
                    ctx.strokeStyle = colors.GOLD_COLOR;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    drawPetalRing(hundreds, colors.HUNDREDS_COLOR, colors.HUNDREDS_STROKE, centerX, centerY, hundredsCircleRadius, petalSizeHundreds);
                }

                 // Cercle guide interne (Dizaines / Unités)
                ctx.beginPath();
                ctx.arc(centerX, centerY, R, 0, 2 * Math.PI);
                ctx.strokeStyle = colors.GOLD_COLOR;
                ctx.lineWidth = 2;
                ctx.stroke();

                 // Dessiner les pétales pour les dizaines sur le cercle interne R
                if (tens > 0) {
                    drawPetalRing(tens, colors.TENS_COLOR, colors.TENS_STROKE, centerX, centerY, R, petalSizeTens);
                }

                // Dessiner les unités à l'intérieur du cercle R
                drawUnits(units, colors, centerX, centerY, R * 0.9, pointRadius); // Légèrement réduit pour ne pas toucher le cercle
            }

            // Fonction qui dessine un anneau de pétales
            function drawPetalRing(count, fillColor, strokeColor, centerX, centerY, radius, petalSize) {
                if (count === 0) return; // Ne rien dessiner si count est 0
                for (let i = 0; i < count; i++) {
                    // Angle: -PI/2 pour commencer en haut, distribue uniformément
                    let angle = -Math.PI / 2 + (i * 2 * Math.PI / count);

                    // Position de la base du pétale sur le cercle guide
                    const petalBaseX = centerX + radius * Math.cos(angle);
                    const petalBaseY = centerY + radius * Math.sin(angle);

                    // Dessine le pétale individuel
                    drawPetal(petalBaseX, petalBaseY, angle, petalSize, fillColor, strokeColor);
                }
            }

            // NOUVELLE FONCTION drawPetal pour un style Yantra/Lotus
            function drawPetal(x, y, angle, petalSize, fillColor, strokeColor) {
                // x, y: point de base du pétale sur le cercle guide
                // angle: direction radiale vers l'extérieur (où pointe le pétale)
                // petalSize: facteur de taille pour le pétale
                // fillColor, strokeColor: couleurs

                // Dimensions du pétale (ajustables pour l'esthétique)
                const petalLength = petalSize * 2.8; // Longueur du pétale
                const petalWidth = petalSize * 1.6;  // Largeur maximale du pétale

                ctx.save(); // Sauvegarde l'état actuel (transformations, styles)
                ctx.translate(x, y); // Place l'origine au point de base du pétale
                ctx.rotate(angle + Math.PI / 2); // Oriente le canvas pour que le pétale pointe vers le "haut" (axe Y négatif local)

                // Coordonnées relatives (base à 0,0, pointe vers le haut sur l'axe Y)
                const baseX = 0;
                const baseY = 0;
                const tipX = 0;
                const tipY = -petalLength; // Pointe vers le Y négatif après rotation

                // Points de contrôle pour les courbes de Bézier cubiques
                // Ajustez ces valeurs pour différentes formes de pétales
                // Courbe 1 (côté droit, de la base à la pointe)
                const cp1X = petalWidth * 0.5;  // Contrôle la largeur à la base
                const cp1Y = -petalLength * 0.3;
                const cp2X = petalWidth * 0.1;  // Contrôle la largeur près de la pointe
                const cp2Y = -petalLength * 0.8;

                // Courbe 2 (côté gauche, de la pointe à la base) - symétrique
                const cp3X = -petalWidth * 0.1; // Symétrique de cp2X
                const cp3Y = -petalLength * 0.8; // Symétrique de cp2Y
                const cp4X = -petalWidth * 0.5;  // Symétrique de cp1X
                const cp4Y = -petalLength * 0.3; // Symétrique de cp1Y

                ctx.beginPath();
                ctx.moveTo(baseX, baseY);
                // Dessine le côté droit du pétale
                ctx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, tipX, tipY);
                // Dessine le côté gauche du pétale
                ctx.bezierCurveTo(cp3X, cp3Y, cp4X, cp4Y, baseX, baseY);
                ctx.closePath();

                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 1.2; // Contour fin
                ctx.stroke();

                ctx.restore(); // Restaure l'état précédent du contexte (translation/rotation)
            }


            // Fonction pour dessiner les unités (inchangée, sauf les couleurs)
             function drawUnits(units, colors, centerX, centerY, innerRadius, pointRadius) {
                ctx.fillStyle = colors.UNITS_COLOR; // Couleur pour le remplissage
                ctx.strokeStyle = colors.UNITS_COLOR; // Couleur pour les lignes
                ctx.lineWidth = 2;

                switch(units) {
                    case 0: break; // Rien à dessiner
                    case 1: // Point central
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, pointRadius * 1.5, 0, 2 * Math.PI); // Un peu plus gros
                        ctx.fill();
                        break;
                    case 2: // Segment vertical
                        drawPolygon(2, -Math.PI/2, colors, centerX, centerY, innerRadius, pointRadius);
                        break;
                    case 3: // Triangle (pointe en haut)
                        drawPolygon(3, -Math.PI / 2, colors, centerX, centerY, innerRadius, pointRadius);
                        break;
                    case 4: // Carré
                         drawPolygon(4, Math.PI / 4, colors, centerX, centerY, innerRadius, pointRadius); // Tourné pour être droit
                        break;
                    case 5: // Carré + point central
                        drawPolygon(4, Math.PI / 4, colors, centerX, centerY, innerRadius, pointRadius);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, pointRadius, 0, 2 * Math.PI);
                        ctx.fill();
                        break;
                    case 6: // Deux triangles (étoile 6 branches)
                        drawPolygon(3, -Math.PI / 2, colors, centerX, centerY, innerRadius, pointRadius);
                        drawPolygon(3, Math.PI / 2, colors, centerX, centerY, innerRadius, pointRadius);
                        break;
                    case 7: // Étoile 6 branches + point central
                         drawPolygon(3, -Math.PI / 2, colors, centerX, centerY, innerRadius, pointRadius);
                         drawPolygon(3, Math.PI / 2, colors, centerX, centerY, innerRadius, pointRadius);
                         ctx.beginPath();
                         ctx.arc(centerX, centerY, pointRadius, 0, 2 * Math.PI);
                         ctx.fill();
                        break;
                    case 8: // Deux carrés tournés
                        drawPolygon(4, Math.PI / 4, colors, centerX, centerY, innerRadius, pointRadius);
                        drawPolygon(4, 0, colors, centerX, centerY, innerRadius, pointRadius); // Deuxième carré non tourné
                        break;
                    case 9: // Deux carrés + point central
                        drawPolygon(4, Math.PI / 4, colors, centerX, centerY, innerRadius, pointRadius);
                        drawPolygon(4, 0, colors, centerX, centerY, innerRadius, pointRadius);
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, pointRadius, 0, 2 * Math.PI);
                        ctx.fill();
                        break;
                }
            }

             // Fonction helper pour dessiner polygones/segments inscrits (utilisée par drawUnits)
            function drawPolygon(sides, rotationOffset, colors, centerX, centerY, radius, pointRadius) {
                if (sides < 2) return; // Un polygone a au moins 2 côtés (segment)

                const points = [];
                // Calcule les sommets du polygone
                for (let i = 0; i < sides; i++) {
                    // Angle pour chaque sommet
                    const angle = rotationOffset + (i * 2 * Math.PI / sides);
                    // Coordonnées du sommet sur le cercle
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    points.push({ x, y });

                     // Dessine un petit cercle à chaque sommet (optionnel mais visuel)
                    ctx.beginPath();
                    ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = colors.UNITS_COLOR; // Utilise déjà la bonne couleur
                    ctx.fill();
                }

                // Dessine les lignes reliant les sommets
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < sides; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                 // Ferme le polygone (ou termine le segment si sides=2)
                if (sides > 2) {
                    ctx.closePath();
                }
                ctx.strokeStyle = colors.UNITS_COLOR; // Utilise déjà la bonne couleur
                ctx.lineWidth = 2;
                ctx.stroke();
            }


            // Initialisation
            updateSliderValue(0); // Afficher 0 au début
            drawNumber(0); // Dessiner l'état initial (0)

            // Ajout des boutons d'exemple dynamiquement
            const exampleNumbers = [42, 100, 1423, 7777, 8008, 9999, 3141, 2718];
            const buttonsContainer = document.querySelector('.buttons-container');
            exampleNumbers.forEach(num => {
                const btn = document.createElement('button');
                btn.classList.add('secondary-btn');
                btn.textContent = `Ex: ${num}`;
                btn.addEventListener('click', function() {
                    currentNumber = num;
                    updateInputs();
                    drawNumberWithAnimation(num);
                     // Optionnel: passer à l'onglet visualisation si on est ailleurs
                    if (!document.getElementById('visualization').classList.contains('active')) {
                         tabs.forEach(t => t.classList.remove('active'));
                         tabContents.forEach(tc => tc.classList.remove('active'));
                         document.querySelector('.tab[data-tab="visualization"]').classList.add('active');
                         document.getElementById('visualization').classList.add('active');
                    }
                });
                buttonsContainer.appendChild(btn);
            });

             // Gestion des flèches clavier pour Précédent/Suivant
            document.addEventListener('keydown', function(e) {
                // Ne pas interférer si l'utilisateur tape dans l'input
                if (document.activeElement === numberInput) return;

                if (e.key === 'ArrowLeft') {
                    e.preventDefault(); // Empêche le scroll horizontal
                    prevBtn.click(); // Simule un clic sur le bouton Précédent
                } else if (e.key === 'ArrowRight') {
                     e.preventDefault(); // Empêche le scroll horizontal
                     nextBtn.click(); // Simule un clic sur le bouton Suivant
                }
            });

        });
    </script>
</body>
</html>
